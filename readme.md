# Техническое задание: Backend

**Срок выполнения:** неделя.

**Отправка готового задания:**  
На почту `m.grishina@i-t-p.pro`.  
В теме письма укажите **Фамилию и Имя**, в теле письма — **ссылку на Git-репозиторий**.

---

## 1. Проектирование схемы БД

**Модель данных:** реляционная.

### Сущности:

#### 1.1. Номенклатура
- Наименование
- Количество
- Цена

#### 1.2. Каталог номенклатуры / Дерево категорий
Требуется хранить данные о категориях товаров с поддержкой **неограниченной вложенности**.  
Схема должна позволять добавлять категории любого уровня вложенности. Максимальный уровень вложенности на этапе проектирования неизвестен.

**Пример дерева категорий:**  
#### 1.3. Клиенты
- Наименование
- Адрес

#### 1.4. Заказы покупателей
Должна быть предусмотрена возможность формирования заказа из **разных наборов товаров**.

**Задача:** спроектировать схему БД без описания бизнес-логики.

---

## 2. SQL-запросы

### 2.1. Сумма товаров по клиентам
Получить информацию о сумме товаров, заказанных каждым клиентом.  
Вывести: **Наименование клиента, сумма**.

### 2.2. Количество дочерних категорий первого уровня
Найти количество дочерних элементов **первого уровня вложенности** для всех категорий номенклатуры.

### 2.3. Отчёт “Топ-5 самых покупаемых товаров за последний месяц”

#### 2.3.1. Запрос для представления (VIEW)
Вывести:
- Наименование товара
- Категория 1-го уровня
- Общее количество проданных штук

#### 2.3.2. Анализ и оптимизация
Проанализировать запрос из п. 2.3.1 и структуру БД.  
Предложить варианты **оптимизации запроса и схемы данных** для повышения производительности в условиях роста данных (тысячи заказов в день).

---

## 3. REST-сервис “Добавление товара в заказ”

**Метод API:** принимает:
- `order_id` (ID заказа)
- `product_id` (ID номенклатуры)
- `quantity` (количество)

**Логика:**
- Если товар уже есть в заказе — увеличить его количество.
- Если товара нет в наличии — вернуть ошибку.

**Стек:** любой Python-фреймворк.  
Приветствуется:
- Git-репозиторий с историей коммитов
- Контейнеризация (Docker)
- Документация (API, README)

---

## Итоговый результат должен включать:

1. **Даталогическая схема данных** (ER-диаграмма, SQL-скрипты создания таблиц).
2. **SQL-запросы** по разделу 2.
3. **Работающий REST-сервис** по разделу 3.

---

# Реляционная схема базы данных для системы управления товарами и заказами

# Решение:

## 1. Схема реляционной БД

### Сущности и таблицы

#### 1.1. `nomenclature` (Номенклатура)
| Поле | Тип | Описание |
|------|------|--------|
| `id` | `SERIAL PRIMARY KEY` | Уникальный ID товара |
| `name` | `VARCHAR(255)` | Наименование товара |
| `quantity` | `INTEGER` | Количество на складе |
| `price` | `DECIMAL(10,2)` | Цена за единицу |

#### 1.2. `categories` (Категории/Дерево категорий)
| Поле | Тип | Описание |
|------|------|--------|
| `id` | `SERIAL PRIMARY KEY` | Уникальный ID категории |
| `name` | `VARCHAR(255)` | Название категории |
| `parent_id` | `INTEGER REFERENCES categories(id)` | Ссылка на родительскую категорию (NULL для корневых) |

*Примечание:*  
- Структура позволяет неограниченную вложенность через `parent_id`.
- Для корневых категорий `parent_id = NULL`.

#### 1.3. `clients` (Клиенты)
| Поле | Тип | Описание |
|------|------|--------|
| `id` | `SERIAL PRIMARY KEY` | Уникальный ID клиента |
| `name` | `VARCHAR(255)` | Наименование клиента |
| `address` | `TEXT` | Адрес клиента |

#### 1.4. `orders` (Заказы)
| Поле | Тип | Описание |
|------|------|--------|
| `id` | `SERIAL PRIMARY KEY` | Уникальный ID заказа |
| `client_id` | `INTEGER REFERENCES clients(id)` | Ссылка на клиента |
| `created_at` | `TIMESTAMP DEFAULT NOW()` | Дата создания заказа |

#### 1.5. `order_items` (Позиции заказа)
| Поле | Тип | Описание |
|------|------|--------|
| `id` | `SERIAL PRIMARY KEY` | Уникальный ID позиции |
| `order_id` | `INTEGER REFERENCES orders(id)` | Ссылка на заказ |
| `nomenclature_id` | `INTEGER REFERENCES nomenclature(id)` | Ссылка на товар |
| `quantity` | `INTEGER` | Количество товара в заказе |

### Связи:

#### nomenclature.category_id → categories.id

#### orders.client_id → clients.id

#### order_items.order_id → orders.id

#### order_items.nomenclature_id → nomenclature.id
![alt text](img/image-1.png)

## SQL‑запросы
### 2.1. Сумма товаров, заказанных каждым клиентом

![alt text](img/image-4.png)

Пояснения:

COALESCE гарантирует 0 вместо NULL для клиентов без заказов;

условие WHERE исключает отменённые заказы;

группировка по c.id, c.name предотвращает дублирование при совпадении имён.

### 2.2. Дочерние категории 1‑го уровня

![alt text](img/image-3.png)

Особенности:

LEFT JOIN сохраняет категории без дочерних элементов;

подсчёт ведётся только для непосредственных потомков (уровень 1).

### 2.3.1. View «Топ‑5 самых покупаемых товаров за последний месяц»
![alt text](img/image-2.png)


### 2.3.2. Анализ и оптимизация
#### Проблемы исходного запроса:

Рекурсивный подзапрос для каждой строки nomenclature — O(n²) по числу категорий.

Полное сканирование orders из‑за отсутствия индекса по created_at.

Нет индекса по status — медленная фильтрация статусов.

Группировка по всему месяцу — высокая нагрузка при росте данных.

#### Оптимизации:

![alt text](img/image-6.png)

Кэширование категорий:

Создать таблицу category_levels с полями:

category_id

root_category_id

level (1, 2, …)

Заполнять её триггером при изменении categories.

# 3. Сервис «Добавление товара в заказ» (Python + FastAPI)

![alt text](img/image-5.png)
